# Number Series, Wrapper and Benchmark

In this assignment, you have to implement a data type (class) `number_series`, to store a number series (just a sequence of integers).

0. Check that the initial project works: select `All CTest` target and run, all tests should pass. **Ask for help if something does not work**, see if you can work with [main.cpp](main.cpp) instead, try running just `main`.

1. Implement `number_series` class
   - Uncomment one test at a time in [number_series_test.cpp](number_series_test.cpp), recompile and observe errors and test failures. 
   - Implement missing functionality (solve `TODO:` comments) in [number_series.hpp](number_series.hpp) until the test passes.
   - Use `std::vector<int>` to model data.
   - Maintain the **minimum** and the **maximum** values of a number series as members of your class (so that you do not have to compute them when needed).
   - Implement the necessary *constructors/destructors/assignment operators*. Implement them only if the ones generated by default are not good. Study Section 17.6 or Item 17 in EMC++ to learn about what is generated by the compiler.
   - Your class should have a **static** member factory function `make_random` that returns a random number series of a desired length. See [uniform_int_distribution example](https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution) how to generate random numbers.
   - Implement `operator+` and `operator+=` to add two number series element-wise. Decide yourself what to do if the number series have different lengths.
   - Implement `operator<` to compare the *amplitudes* of two number series. The amplitude is the difference between the *maximum* and the *minimum* values.
2. Solve `TODO`s in [number_series_bm.cpp](number_series_bm.cpp) benchmark and run `number_series_bm` target in `Release` profile:
   - Fill a vector of `100'000` random number series, each with `100` elements.
   - Add a random number series to each of number series in the vector.
   - Sort the vector according to the amplitudes of number series. 
   - Record how much time it takes to sort (remember to write down the timings in comments).
3. Create a wrapper class, that has just one private data member: `std::unique_ptr<number_series>` and add the same interface as for `number_series`. Think about the copy/move constructors/assignment operators, that you may need to provide or rely on the default ones. On the client side in [number_series_bm.cpp](number_series_bm.cpp), demonstrate that you can now use essentially the same code as in step 2.
   - What do you expect regarding the performance of sorting objects of this wrapper class when compared to sorting the original `number_series` objects?
   - Measure the performance and see whether your expectations were confirmed.
4. Add `int dummy[100];` as an extra data member of `number_series`.
   - Rerun `number_series_bm` again.
   - How did the performance change? Why?

In your code, pay attention to **safety** and **performance**:
1. Use `const` whenever it makes sense (arguments, member functions). 
2. Use pass-by-reference for efficiency whenever possible.
3. Avoid using plain pointers.
4. Use `Release` profile (without `Debug` info overhead) when benchmarking. To add `Release` profile in CLion visit `Settings` > `Build, Execution and Deployment` > `CMake` > `Profiles` and click `+`, it should create `Release` profile automatically (no further tweaking should be needed).

## Unit Tests
[number_series_test.cpp](number_series_test.cpp) includes unit tests to guide you through the implementation.

## Benchmarks
[sort_bm.cpp](sort_bm.cpp) includes a sorting example demonstrating how to use Google Benchmark library.
[number_series_bm.cpp](number_series_bm.cpp) your code for benchmarking the `number_series` and `number_series_wrap`.

## Libraries included
- [doctest](https://github.com/doctest/doctest): unit test framework.
- [Google Benchmark](https://github.com/google/benchmark): microbenchmark support library.

CMake should fetch those libraries automatically during `cmake` reload, and the libraries should build automatically when building the project.